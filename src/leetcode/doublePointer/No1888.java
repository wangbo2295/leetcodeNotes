package leetcode.doublePointer;

/**
 * 给你一个二进制字符串s。你可以按任意顺序执行以下两种操作任意次：
 * 类型 1 ：删除 字符串s的第一个字符并将它 添加到字符串结尾。
 * 类型 2 ：选择 字符串s中任意一个字符并将该字符反转，也就是如果值为'0'，则反转得到'1'，反之亦然。
 * 请你返回使 s变成 交替 字符串的前提下，类型 2的 最少操作次数。
 * 我们称一个字符串是 交替的，需要满足任意相邻字符都不同。
 * 比方说，字符串"010" 和"1010"都是交替的，但是字符串"0100"不是。
 */
public class No1888 {
    /**
     * 思路：滑动窗口
     * 为了使操作 2 次数最小，可以先枚举所有操作 1 ，计算经过若干次操作 1 后需要多少次操作 2 才能交替，最终取最小值
     * 如何枚举所有操作 1 ？可以再 s 后面再拼接一份 s，用一个大小为 n 的滑动窗口表示当前操作 1 之后的字符串
     * 每次窗口向后滑动一步，就相当于进行一次操作 1 。
     * 为了快速计算操作 2 的次数，可以预处理出拼接后的前缀操作次数，通过差分的方式快速得到当前窗口下需要多少次操作 2 能交替，同时要考虑 101 和 010 两种交替模式
     */
    public int minFlips(String s) {
        s += s;
        int n = s.length();
        int[][] ps = new int[n + 1][2];
        int flag = 0;
        for (int i = 1; i <= n; i++) {
            int c = s.charAt(i - 1) - '0';
            ps[i][0] = ps[i - 1][0];
            ps[i][1] = ps[i - 1][1];
            if (c != flag) ps[i][0]++;
            if (c != (flag ^ 1)) ps[i][1]++;
            flag ^= 1;
        }
        int ans = n;
        for (int i = n >> 1; i <= n; i++) {
            ans = Math.min(ans, Math.min(ps[i][0] - ps[i - n / 2][0], ps[i][1] - ps[i - n / 2][1]));
        }
        return ans;
    }
}
