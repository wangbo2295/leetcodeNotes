package leetcode.dynamicPrograming;

/**
 * 给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 <= x < 10n 。
 */
public class No357 {
    /**
     * F[n] 为各位都不同的数的个数， A(i, j)为排列数，意味着在i个数中选重复的数，选j个数进行组合，考虑排列顺序，一共有多少种可能
     * 记n位数中，n个位均不同的数的个数为G[n], 那么F[n] = G[1] + G[2] + ... + G[n]
     * 递推公式： F[n] = F[n - 1] + G[n]
     * 如何求G[n] ?
     * 举例：
     * n = 1， 0，1，2，3，4，5，6，7，8，9   F[1] = G[1] = 10
     * n = 2,  10, 12, 13, 14, 15, 16, 17, 18, 19 ... (第一位在1-9中选，第二位在0-9中选)
     * 观察到在 n = 1 中的不含0的数前加上0，就能和n = 2中的数组成A(10, 2)。（因为有前导0不算，所以算上前导0的数量为第一位选0，其他位在1 - 9中选）
     * 由此得到A(10, n) = A(9, n - 1) + G[n]，变形得到：
     * G[n] = A(10, n) - A(9, n - 1)，最终的递推公式为：
     * F[n] = F[n - 1] + A(10, n) - A(9, n - 1)
     * A[i, j] 的计算公式： i! / (i - j) !
     * 我们用一个数组存储1 - 10的阶乘结果，再带入上述递推公式即可。
     * @param n
     * @return
     */
    public int countNumbersWithUniqueDigits(int n) {
        int[] fac = new int[11];
        fac[0] = 1;
        for (int i = 1; i <= 10; i++) {
            fac[i] = fac[i - 1] * i;
        }
        int res = 1;    //初始化为1，是为了正确的计算F[1]，因为F[0]没意义
        for (int i = 1; i <= n; i++) {
            res += fac[10] / fac[10 - i] - fac[9] / fac[9 - (i - 1)];
        }
        return res;
    }
}
